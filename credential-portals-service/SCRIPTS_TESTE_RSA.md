# üß™ Scripts de Teste e Valida√ß√£o - Criptografia RSA

## üéØ Vis√£o Geral dos Testes

Este documento cont√©m scripts para testar e validar a implementa√ß√£o completa da criptografia RSA para consumidores da API de credenciais.

## üîß Scripts de Teste com cURL

### **Script 1: Teste Completo do Fluxo RSA**

```bash
#!/bin/bash

# Configura√ß√µes
API_BASE_URL="http://localhost:8084"
CONSUMER_ID="test-consumer-$(date +%s)"

echo "üöÄ Iniciando teste completo do fluxo RSA..."
echo "üìã Consumer ID: $CONSUMER_ID"
echo ""

# 1. Gerar exemplo de chaves
echo "üîë 1. Gerando par de chaves RSA..."
KEY_RESPONSE=$(curl -s -X GET "$API_BASE_URL/api/consumer-keys/generate-example")

if [ $? -eq 0 ]; then
    echo "‚úÖ Chaves geradas com sucesso!"
    
    # Extrair chaves da resposta
    PUBLIC_KEY=$(echo $KEY_RESPONSE | jq -r '.publicKey')
    PRIVATE_KEY=$(echo $KEY_RESPONSE | jq -r '.privateKey')
    
    echo "üì§ Chave p√∫blica extra√≠da: ${PUBLIC_KEY:0:64}..."
    echo "üîê Chave privada extra√≠da: ${PRIVATE_KEY:0:64}..."
else
    echo "‚ùå Falha ao gerar chaves"
    exit 1
fi

echo ""

# 2. Registrar chave p√∫blica
echo "üìù 2. Registrando chave p√∫blica na API..."
REGISTER_RESPONSE=$(curl -s -X POST "$API_BASE_URL/api/consumer-keys" \
    -H "Content-Type: application/json" \
    -d "{
        \"consumerName\": \"Test Consumer App\",
        \"consumerIdentifier\": \"$CONSUMER_ID\",
        \"publicKey\": \"$PUBLIC_KEY\",
        \"description\": \"Teste automatizado do fluxo RSA\",
        \"expiresAt\": \"2025-12-31T23:59:59\"
    }")

if [ $? -eq 0 ]; then
    echo "‚úÖ Chave p√∫blica registrada com sucesso!"
    echo "üìã Resposta: $REGISTER_RESPONSE"
else
    echo "‚ùå Falha ao registrar chave p√∫blica"
    exit 1
fi

echo ""

# 3. Verificar se h√° credenciais no banco
echo "üìä 3. Verificando credenciais dispon√≠veis..."
CREDENTIALS_COUNT=$(curl -s -X GET "$API_BASE_URL/api/credentials" | jq length)

if [ "$CREDENTIALS_COUNT" -eq 0 ]; then
    echo "‚ÑπÔ∏è  Nenhuma credencial encontrada. Criando credencial de teste..."
    
    # Criar credencial de teste
    TEST_CREDENTIAL=$(curl -s -X POST "$API_BASE_URL/api/credentials" \
        -H "Content-Type: application/json" \
        -d '{
            "nameMall": "Shopping Teste RSA",
            "cnpj": "12345678901234",
            "urlPortal": "https://portal-teste-rsa.com",
            "username": "admin-teste",
            "password": "SenhaSecreta123!"
        }')
    
    if [ $? -eq 0 ]; then
        echo "‚úÖ Credencial de teste criada!"
        echo "üìã Credencial: $TEST_CREDENTIAL"
    else
        echo "‚ùå Falha ao criar credencial de teste"
        exit 1
    fi
else
    echo "‚úÖ Encontradas $CREDENTIALS_COUNT credenciais no sistema"
fi

echo ""

# 4. Buscar credenciais com senhas criptografadas
echo "üîí 4. Buscando credenciais com senhas criptografadas..."
ENCRYPTED_CREDENTIALS=$(curl -s -X GET "$API_BASE_URL/api/credentials/encrypted/$CONSUMER_ID")

if [ $? -eq 0 ]; then
    echo "‚úÖ Credenciais criptografadas obtidas com sucesso!"
    
    # Extrair primeira credencial para teste
    FIRST_CREDENTIAL=$(echo $ENCRYPTED_CREDENTIALS | jq '.[0]')
    ENCRYPTED_PASSWORD=$(echo $FIRST_CREDENTIAL | jq -r '.encryptedPassword')
    MALL_NAME=$(echo $FIRST_CREDENTIAL | jq -r '.nameMall')
    
    echo "üè¢ Shopping: $MALL_NAME"
    echo "üîê Senha criptografada: ${ENCRYPTED_PASSWORD:0:64}..."
else
    echo "‚ùå Falha ao buscar credenciais criptografadas"
    exit 1
fi

echo ""

# 5. Simular descriptografia (usando Node.js)
echo "üîì 5. Testando descriptografia da senha..."

# Criar script Node.js tempor√°rio para descriptografia
cat > temp_decrypt.js << EOF
const crypto = require('crypto');

const privateKeyPem = \`$PRIVATE_KEY\`;
const encryptedPassword = '$ENCRYPTED_PASSWORD';

try {
    const buffer = Buffer.from(encryptedPassword, 'base64');
    const decrypted = crypto.privateDecrypt(privateKeyPem, buffer);
    console.log('‚úÖ Senha descriptografada com sucesso: ' + decrypted.toString('utf8'));
} catch (error) {
    console.log('‚ùå Erro na descriptografia: ' + error.message);
    process.exit(1);
}
EOF

# Executar descriptografia
if command -v node &> /dev/null; then
    node temp_decrypt.js
    rm temp_decrypt.js
else
    echo "‚ö†Ô∏è  Node.js n√£o encontrado. Pulando teste de descriptografia."
fi

echo ""

# 6. Validar chave registrada
echo "‚úÖ 6. Validando chave registrada..."
VALIDATION_RESPONSE=$(curl -s -X GET "$API_BASE_URL/api/consumer-keys/consumer/$CONSUMER_ID")

if [ $? -eq 0 ]; then
    IS_VALID=$(echo $VALIDATION_RESPONSE | jq -r '.isValid')
    CONSUMER_NAME=$(echo $VALIDATION_RESPONSE | jq -r '.consumerName')
    
    echo "‚úÖ Chave validada!"
    echo "üìã Consumer: $CONSUMER_NAME"
    echo "üîç V√°lida: $IS_VALID"
else
    echo "‚ùå Falha ao validar chave"
fi

echo ""

# 7. Limpeza (opcional)
echo "üßπ 7. Limpeza dos dados de teste..."
read -p "Deseja remover os dados de teste criados? (y/n): " -r
if [[ $REPLY =~ ^[Yy]$ ]]; then
    # Buscar ID da chave para remo√ß√£o
    KEY_ID=$(echo $VALIDATION_RESPONSE | jq -r '.id')
    
    if [ "$KEY_ID" != "null" ]; then
        DELETE_RESPONSE=$(curl -s -X DELETE "$API_BASE_URL/api/consumer-keys/$KEY_ID")
        if [ $? -eq 0 ]; then
            echo "‚úÖ Chave p√∫blica removida"
        else
            echo "‚ö†Ô∏è  Falha ao remover chave p√∫blica"
        fi
    fi
fi

echo ""
echo "üéâ Teste completo finalizado!"
echo "üìä Resumo:"
echo "   ‚úÖ Gera√ß√£o de chaves RSA"
echo "   ‚úÖ Registro de chave p√∫blica"
echo "   ‚úÖ Busca de credenciais criptografadas"
echo "   ‚úÖ Descriptografia de senhas"
echo "   ‚úÖ Valida√ß√£o de chaves"
```

### **Script 2: Teste de Performance e Carga**

```bash
#!/bin/bash

# Configura√ß√µes
API_BASE_URL="http://localhost:8084"
NUM_CONSUMERS=10
NUM_REQUESTS_PER_CONSUMER=5

echo "‚ö° Iniciando teste de performance..."
echo "üë• Consumidores: $NUM_CONSUMERS"
echo "üìä Requests por consumidor: $NUM_REQUESTS_PER_CONSUMER"
echo ""

# Fun√ß√£o para testar um consumidor
test_consumer() {
    local consumer_id="perf-test-$1"
    local start_time=$(date +%s.%N)
    
    echo "üöÄ Testando consumidor: $consumer_id"
    
    # Gerar chaves
    local key_response=$(curl -s -X GET "$API_BASE_URL/api/consumer-keys/generate-example")
    local public_key=$(echo $key_response | jq -r '.publicKey')
    
    # Registrar chave
    curl -s -X POST "$API_BASE_URL/api/consumer-keys" \
        -H "Content-Type: application/json" \
        -d "{
            \"consumerName\": \"Performance Test $1\",
            \"consumerIdentifier\": \"$consumer_id\",
            \"publicKey\": \"$public_key\",
            \"description\": \"Teste de performance $1\"
        }" > /dev/null
    
    # Fazer m√∫ltiplas requisi√ß√µes
    for ((j=1; j<=NUM_REQUESTS_PER_CONSUMER; j++)); do
        curl -s -X GET "$API_BASE_URL/api/credentials/encrypted/$consumer_id" > /dev/null
    done
    
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)
    
    echo "‚è±Ô∏è  Consumidor $consumer_id: ${duration}s"
}

# Executar testes em paralelo
for ((i=1; i<=NUM_CONSUMERS; i++)); do
    test_consumer $i &
done

# Aguardar todos os processos
wait

echo "‚úÖ Teste de performance conclu√≠do!"
```

### **Script 3: Valida√ß√£o de Seguran√ßa**

```bash
#!/bin/bash

API_BASE_URL="http://localhost:8084"

echo "üîí Iniciando testes de seguran√ßa..."
echo ""

# Teste 1: Tentativa de acesso sem chave registrada
echo "üß™ Teste 1: Acesso sem chave registrada"
RESPONSE=$(curl -s -w "%{http_code}" -X GET "$API_BASE_URL/api/credentials/encrypted/consumer-inexistente")
HTTP_CODE="${RESPONSE: -3}"

if [ "$HTTP_CODE" == "404" ]; then
    echo "‚úÖ Bloqueou acesso sem chave registrada (HTTP $HTTP_CODE)"
else
    echo "‚ùå Falha na seguran√ßa: permitiu acesso sem chave (HTTP $HTTP_CODE)"
fi

echo ""

# Teste 2: Tentativa de registro de chave inv√°lida
echo "üß™ Teste 2: Registro de chave RSA inv√°lida"
INVALID_KEY_RESPONSE=$(curl -s -w "%{http_code}" -X POST "$API_BASE_URL/api/consumer-keys" \
    -H "Content-Type: application/json" \
    -d '{
        "consumerName": "Test Invalid Key",
        "consumerIdentifier": "invalid-key-test",
        "publicKey": "chave-invalida-base64",
        "description": "Teste de chave inv√°lida"
    }')

INVALID_HTTP_CODE="${INVALID_KEY_RESPONSE: -3}"

if [ "$INVALID_HTTP_CODE" == "400" ]; then
    echo "‚úÖ Rejeitou chave inv√°lida (HTTP $INVALID_HTTP_CODE)"
else
    echo "‚ùå Falha na valida√ß√£o: aceitou chave inv√°lida (HTTP $INVALID_HTTP_CODE)"
fi

echo ""

# Teste 3: Verificar se senhas n√£o s√£o retornadas em texto plano
echo "üß™ Teste 3: Verificar se senhas n√£o vazam em texto plano"
PLAIN_CREDENTIALS=$(curl -s -X GET "$API_BASE_URL/api/credentials")

if echo "$PLAIN_CREDENTIALS" | grep -q '"password"'; then
    echo "‚ùå ALERTA: Senhas sendo retornadas em texto plano!"
else
    echo "‚úÖ Senhas n√£o s√£o expostas em endpoints normais"
fi

echo ""

# Teste 4: Verificar criptografia das senhas no banco
echo "üß™ Teste 4: Validar que senhas s√£o criptografadas no banco"
echo "‚ÑπÔ∏è  Este teste requer acesso direto ao banco de dados"
echo "   Execute: SELECT password FROM credentials LIMIT 1;"
echo "   A senha deve come√ßar com '$2b$' (BCrypt)"

echo ""
echo "üéØ Testes de seguran√ßa conclu√≠dos!"
```

## üêç Script de Teste em Python

```python
#!/usr/bin/env python3
"""
Script de teste completo para validar a implementa√ß√£o RSA
"""

import requests
import base64
import json
import time
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.backends import default_backend

class RSATestSuite:
    def __init__(self, api_base_url="http://localhost:8084"):
        self.api_base_url = api_base_url
        self.consumer_id = f"python-test-{int(time.time())}"
        self.private_key = None
        self.public_key = None
        
    def generate_keys(self):
        """Gera par de chaves RSA para teste"""
        print("üîë Gerando par de chaves RSA...")
        
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        self.public_key = self.private_key.public_key()
        
        print("‚úÖ Chaves geradas com sucesso!")
        
    def public_key_to_base64(self):
        """Converte chave p√∫blica para Base64"""
        pem = self.public_key.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        return base64.b64encode(pem).decode('utf-8')
        
    def register_public_key(self):
        """Registra chave p√∫blica na API"""
        print("üìù Registrando chave p√∫blica...")
        
        url = f"{self.api_base_url}/api/consumer-keys"
        data = {
            "consumerName": "Python Test Suite",
            "consumerIdentifier": self.consumer_id,
            "publicKey": self.public_key_to_base64(),
            "description": "Teste automatizado Python",
            "expiresAt": "2025-12-31T23:59:59"
        }
        
        response = requests.post(url, json=data)
        
        if response.status_code == 201:
            print("‚úÖ Chave p√∫blica registrada!")
            return response.json()
        else:
            raise Exception(f"Falha ao registrar chave: {response.text}")
            
    def create_test_credential(self):
        """Cria credencial de teste"""
        print("üìä Criando credencial de teste...")
        
        url = f"{self.api_base_url}/api/credentials"
        data = {
            "nameMall": "Shopping Teste Python",
            "cnpj": "98765432109876",
            "urlPortal": "https://portal-python-test.com",
            "username": "python-test",
            "password": "TestePython@2024!"
        }
        
        response = requests.post(url, json=data)
        
        if response.status_code == 201:
            print("‚úÖ Credencial de teste criada!")
            return response.json()
        else:
            print(f"‚ö†Ô∏è  Usando credenciais existentes: {response.status_code}")
            
    def get_encrypted_credentials(self):
        """Busca credenciais com senhas criptografadas"""
        print("üîí Buscando credenciais criptografadas...")
        
        url = f"{self.api_base_url}/api/credentials/encrypted/{self.consumer_id}"
        response = requests.get(url)
        
        if response.status_code == 200:
            credentials = response.json()
            print(f"‚úÖ Encontradas {len(credentials)} credenciais criptografadas!")
            return credentials
        else:
            raise Exception(f"Falha ao buscar credenciais: {response.text}")
            
    def decrypt_password(self, encrypted_password):
        """Descriptografa senha usando chave privada"""
        print("üîì Descriptografando senha...")
        
        try:
            encrypted_bytes = base64.b64decode(encrypted_password)
            
            decrypted_bytes = self.private_key.decrypt(
                encrypted_bytes,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            
            decrypted_password = decrypted_bytes.decode('utf-8')
            print(f"‚úÖ Senha descriptografada: {decrypted_password}")
            return decrypted_password
            
        except Exception as e:
            raise Exception(f"Falha na descriptografia: {str(e)}")
            
    def run_performance_test(self, num_requests=10):
        """Executa teste de performance"""
        print(f"‚ö° Executando teste de performance ({num_requests} requests)...")
        
        url = f"{self.api_base_url}/api/credentials/encrypted/{self.consumer_id}"
        
        start_time = time.time()
        success_count = 0
        
        for i in range(num_requests):
            try:
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    success_count += 1
            except Exception as e:
                print(f"‚ùå Request {i+1} falhou: {str(e)}")
                
        end_time = time.time()
        duration = end_time - start_time
        
        print(f"üìä Performance:")
        print(f"   ‚è±Ô∏è  Tempo total: {duration:.2f}s")
        print(f"   ‚úÖ Sucessos: {success_count}/{num_requests}")
        print(f"   üìà Requests/segundo: {success_count/duration:.2f}")
        
    def run_full_test(self):
        """Executa suite completa de testes"""
        print("üöÄ Iniciando suite completa de testes RSA")
        print(f"üìã Consumer ID: {self.consumer_id}")
        print("=" * 50)
        
        try:
            # 1. Gerar chaves
            self.generate_keys()
            
            # 2. Registrar chave p√∫blica
            registration_result = self.register_public_key()
            
            # 3. Criar credencial de teste
            self.create_test_credential()
            
            # 4. Buscar credenciais criptografadas
            encrypted_credentials = self.get_encrypted_credentials()
            
            # 5. Testar descriptografia
            if encrypted_credentials:
                first_credential = encrypted_credentials[0]
                encrypted_password = first_credential['encryptedPassword']
                
                print(f"üè¢ Shopping: {first_credential['nameMall']}")
                print(f"üë§ Usu√°rio: {first_credential['username']}")
                
                decrypted_password = self.decrypt_password(encrypted_password)
                
            # 6. Teste de performance
            self.run_performance_test()
            
            print("=" * 50)
            print("üéâ Todos os testes passaram com sucesso!")
            
        except Exception as e:
            print(f"‚ùå Erro durante os testes: {str(e)}")
            
    def cleanup(self):
        """Remove dados de teste"""
        print("üßπ Limpando dados de teste...")
        
        # Buscar chave para remo√ß√£o
        try:
            url = f"{self.api_base_url}/api/consumer-keys/consumer/{self.consumer_id}"
            response = requests.get(url)
            
            if response.status_code == 200:
                key_data = response.json()
                key_id = key_data['id']
                
                # Remover chave
                delete_url = f"{self.api_base_url}/api/consumer-keys/{key_id}"
                delete_response = requests.delete(delete_url)
                
                if delete_response.status_code == 200:
                    print("‚úÖ Chave de teste removida!")
                else:
                    print("‚ö†Ô∏è  Falha ao remover chave de teste")
                    
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro na limpeza: {str(e)}")

if __name__ == "__main__":
    # Executar testes
    test_suite = RSATestSuite()
    
    try:
        test_suite.run_full_test()
    finally:
        # Limpeza
        cleanup_input = input("\nüóëÔ∏è  Deseja limpar os dados de teste? (y/n): ")
        if cleanup_input.lower() in ['y', 'yes', 's', 'sim']:
            test_suite.cleanup()
```

## üìä Script para Monitoramento e M√©tricas

```bash
#!/bin/bash

# Script de monitoramento da API RSA
API_BASE_URL="http://localhost:8084"
LOG_FILE="rsa_monitoring.log"

echo "üìä Iniciando monitoramento da API RSA..."
echo "üìÅ Logs salvos em: $LOG_FILE"
echo ""

# Fun√ß√£o para log com timestamp
log_with_timestamp() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

# Loop de monitoramento
while true; do
    # Verificar sa√∫de da API
    HEALTH_RESPONSE=$(curl -s -w "%{http_code}" -X GET "$API_BASE_URL/actuator/health" 2>/dev/null)
    HEALTH_CODE="${HEALTH_RESPONSE: -3}"
    
    if [ "$HEALTH_CODE" == "200" ]; then
        log_with_timestamp "‚úÖ API saud√°vel (HTTP $HEALTH_CODE)"
    else
        log_with_timestamp "‚ùå API com problema (HTTP $HEALTH_CODE)"
    fi
    
    # Contar chaves registradas
    KEYS_COUNT=$(curl -s -X GET "$API_BASE_URL/api/consumer-keys" 2>/dev/null | jq length 2>/dev/null || echo "0")
    log_with_timestamp "üîë Chaves registradas: $KEYS_COUNT"
    
    # Contar credenciais
    CREDENTIALS_COUNT=$(curl -s -X GET "$API_BASE_URL/api/credentials" 2>/dev/null | jq length 2>/dev/null || echo "0")
    log_with_timestamp "üìä Credenciais cadastradas: $CREDENTIALS_COUNT"
    
    echo "---"
    
    # Aguardar 30 segundos
    sleep 30
done
```

## üéØ Como Executar os Testes

### **Pr√©-requisitos:**
```bash
# Instalar depend√™ncias
sudo apt-get install curl jq bc nodejs python3 python3-pip

# Python
pip3 install requests cryptography
```

### **Execu√ß√£o:**

1. **Teste completo com Bash:**
   ```bash
   chmod +x test_rsa_complete.sh
   ./test_rsa_complete.sh
   ```

2. **Teste de performance:**
   ```bash
   chmod +x test_rsa_performance.sh
   ./test_rsa_performance.sh
   ```

3. **Teste de seguran√ßa:**
   ```bash
   chmod +x test_rsa_security.sh
   ./test_rsa_security.sh
   ```

4. **Suite Python:**
   ```bash
   python3 test_rsa_suite.py
   ```

5. **Monitoramento cont√≠nuo:**
   ```bash
   chmod +x monitor_rsa.sh
   ./monitor_rsa.sh
   ```

## üìà Interpreta√ß√£o dos Resultados

### **Resultados Esperados:**
- ‚úÖ **Gera√ß√£o de chaves:** Sempre deve funcionar
- ‚úÖ **Registro:** HTTP 201 para chaves v√°lidas, 400 para inv√°lidas
- ‚úÖ **Criptografia:** Senhas nunca em texto plano na API
- ‚úÖ **Descriptografia:** Senha original deve ser recuperada
- ‚úÖ **Seguran√ßa:** Acesso negado para consumidores n√£o registrados

### **M√©tricas de Performance:**
- **Tempo de resposta:** < 500ms para opera√ß√µes RSA
- **Throughput:** > 10 requests/segundo
- **Taxa de sucesso:** > 99%

Estes scripts garantem que toda a implementa√ß√£o RSA est√° funcionando corretamente e com seguran√ßa!
